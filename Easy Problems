1. Two Sum
Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.
You may assume that each input would have exactly one solution, and you may not use the same element twice.
You can return the answer in any order.

Example 1:

Input: nums = [2,7,11,15], target = 9
Output: [0,1]
Explanation: Because nums[0] + nums[1] == 9, we return [0, 1].

Solution:
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number[]}
 */
var twoSum = function(nums, target) {
    // for(let i=0;i<nums.length;i++){
    //     // if(nums[i]+nums[i+1] === target){
    //     //     return [i,i+1]
    //     // }
    //     for(let j=i+1;j<nums.length;j++){
    //         if(nums[i]+nums[j] === target){
    //             return [i,j]
    //         }
    //     }
    // }
    let map = new Map();
    for(let i=0;i<nums.length;i++){
        let n= nums[i];
        let more = target-n;

        if(map.has(more)){
            return [map.get(more),i]
        }else{
            map.set(n,i)
        }
    }
};


217. Contains Duplicate
Given an integer array nums, return true if any value appears at least twice in the array, and return false if every element is distinct.

Sol:
/**
 * @param {number[]} nums
 * @return {boolean}
 */
var containsDuplicate = function(nums) {
    // let appear= {};
    // for(let i=0;i<nums.length;i++){
    //     let n = nums[i];
    //     if(appear[n] !== undefined){
    //         return true;
    //     }else {
    //         appear[n] =nums[i];
    //     }
    // }
    // return false;

    // let dup =0;
    // nums.sort();

    // for(let i=0;i<nums.length;i++){
    //     if(nums[i] === nums[i+1]){
    //         dup++;
    //     }
    // }

    // return dup !=0;

    // using hash map

    let map = new Map()
    for (let num of nums){
        if(map.has(num)){
            return true;
        }else{
            map.set(num,true);
        }
    }
    return false;
};


219. Contains Duplicate II
Given an integer array nums and an integer k, return true if there are two distinct indices i and j in the array such that nums[i] == nums[j] and abs(i - j) <= k.

Sol:
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {boolean}
 */
var containsNearbyDuplicate = function (nums, k) {
    let map = new Map()
    for (let i = 0; i < nums.length; i++) {
        let n = nums[i]
        if (map.has(n) && Math.abs(map.get(n) - i) <= k) {
            return true;
        } else {
            map.set(n, i);
        }
    }
    return false;
};


For node only:

process.stdout.write("hello")
process.stdout.write("world") // hello world both will give output in one line


Pattern programming:

1.  *
    **
    ***
    ****
    *****

Sol:
 for(let i =1;i<=5;i++){
    for(let j=1;j<=i;j++){
        process.stdout.write('*');
    }
    console.log()
}

2.  1
    12
    123
    1234
    12345

for(let i =1;i<=5;i++){
    for(let j=1;j<=i;j++){
        process.stdout.write(j.toString());
    }
    console.log()
}

3.  A
    AB
    ABC
    ABCD
    ABCDE

sol: 
for(let i =1;i<=5;i++){
    let ascii = 65;  // Ascii value of A is 65
    for(let j=1;j<=i;j++){
        process.stdout.write(String.fromCharCode(ascii));
        ascii++;
    }
    console.log()
}

for(let i =1;i<=5;i++){
    let ascii = 97;  // Ascii value of a is 97
    for(let j=1;j<=i;j++){
        process.stdout.write(String.fromCharCode(ascii));
        ascii++;
    }
    console.log()
}


console.log('a'.charCodeAt(0))
console.log(String.fromCharCode(97))


4.  *****
    ****
    ***
    **
    *
Sol:
for(let i=5;i>=1;i--){
    for(let j=1;j<=i;j++){
        process.stdout.write('*')
    }
    console.log()
}

5.
    *
   **
  ***
 ****
*****

Sol: 
let n = 5;
for (let i = 1; i <= n; i++) {
    for (let j = 1; j <= n; j++) {
        if (j > (n - i)) {
            process.stdout.write('*');
        } else {
            process.stdout.write(' ');
        }
    }
    console.log(); // Moves to the next line
}

6. * 
  * * 
 * * * 
* * * * 
* * * * * 

Sol:
let n = 5;
for (let i = 1; i <= n; i++) {
    let str='';
    for(let j=0;j<n-1-i;j++){
        str+=' '
    }
    
    for(let j=0;j<i;j++){
        str+='* '
    }
    console.log(str)
}

7. 
*   *
 * * 
  *  
 * * 
*   *

Sol:  
let n = 5;

for(let i=1;i<=n;i++){
    for(let j=1;j<=n;j++){
        if(i===j){
            process.stdout.write('*')
        }else if(i+j === n+1){
            process.stdout.write('*')
        }else{
            process.stdout.write(' ')
        }
    }
    console.log()
}

8. 
*       *
 *     * 
  *   *  
   * *   
    *    

Sol:
let n = 5;

for(let i=1;i<=n;i++){
    for(let j=1;j<=2*n-1;j++){
        if(i===j || (i+j === 2*n) ){
            process.stdout.write('*')
        }else{
            process.stdout.write(' ')
        }
    }
    console.log()
}


Q.Reversing a array without creating new array

Sol:
let arr = [24,1,4,34,5];

let i= 0, j= arr.length-1;
while(i!=j){
    let temp =arr[i];
    arr[i]= arr[j];
    arr[j] = temp;
    i++;
    j--;
}

Q. In array bring 0 to one side and 1 to another.

Sol:
et arr = [1,0,0,1,1,0,0,1];

let i = 0, j=0;

while(i<arr.length){
    if(arr[i] === 0){
        let temp = arr[i];
        arr[i]=arr[j];
        arr[j] = temp;
        j++
    }
    i++
}
[
  0, 0, 0, 0,
  1, 1, 1, 1
]

Q. shifting array 1 point right or left.

Sol:

let arr = [1,2,3,4,5];

let copy = arr[arr.length-1];

for(let i =0;i<arr.length-1;i++){
        
    arr[i] = arr[i+1]
    
}   
        arr[arr.length-1] = copy;

for(let i = arr.length-1;i>0;i--){
    arr[i] = arr[i-1];
}
arr[0]= copy

console.log("Moved arr is:", arr)


Q. reverse array for k times.
Sol: /**
 * @param {number[]} nums
 * @param {number} k
 * @return {void} Do not return anything, modify nums in-place instead.
 */
var rotate = function(nums, k) {
    k = k% nums.length;

    // reverse(0, nums.length-1, nums)
    nums.reverse()

    reverse(0, k-1, nums)
    reverse(k,nums.length-1, nums)
};

const reverse = function(start, end,arr){
    while(start< end){
        let temp= arr[start];
        arr[start] = arr[end];
        arr[end] = temp;
        start++;
        end--;
    }
}


More solution:
left rotation :  arr[i]= arr[(i+k)%arr.length]

right rotation: arr[(i+k)% arr.length] = arr[i]

Q: 75. Sort Colors
Given an array nums with n objects colored red, white, or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white, and blue.
We will use the integers 0, 1, and 2 to represent the color red, white, and blue, respectively.
You must solve this problem without using the library's sort function.

Sol:
ar sortColors = function(nums) {
    let i =0,j=0;
    let k = nums.length -1;

    while(i<=k){
        if(nums[i] === 0){
            let temp = nums[i];
            nums[i] = nums[j];
            nums[j]= temp;
            i++;
            j++;
        }else if(nums[i] === 2){
            let temp = nums[i];
            nums[i]= nums[k];
            nums[k]=temp;
            k--;
        }else {
            i++;
        }
    }
    return nums;
};

Q: Maximum subarray
Given an integer array nums, find the subarray with the largest sum, and return its sum.
Example 1:
Input: nums = [-2,1,-3,4,-1,2,1,-5,4]
Output: 6
Explanation: The subarray [4,-1,2,1] has the largest sum 6.

Sol:

USING KENDEY'S ALGORITHM
var maxSubArray = function(nums) {
    let i=0;
    let max= nums[0];
    let sum=0;

    while(i<nums.length){
        sum+= nums[i]
         if(sum > max){
        max= sum
        }
        if(sum <0) {
            sum = 0;
        }
       
        i++;
    }
    return max;
};

Q: MOORE'S VOTING ALGORITHM
169. Majority Element
Given an array nums of size n, return the majority element.
The majority element is the element that appears more than ⌊n / 2⌋ times. You may assume that the majority element always exists in the array.
Normal Solution:
var majorityElement = function(nums) {
    let map = new Map();

    for(let i=0;i<nums.length;i++){
        let exist= map.get(nums[i]);
        if(exist){
            map.set(nums[i], exist+1)
        }else {
            map.set(nums[i], 1)
        }
    }
    let majority = nums.length/2;

    for( const [key, value] of map){
        if(value > majority){
            return key;
        }
    }
};

USING ALGO:
let ans= nums[0];
    let count =1;
    for(let i=1;i<nums.length;i++){
        if(count == 0){
            ans= nums[i];
            count =1;
        }else if(ans == nums[i]){
            count++;
        }else {
            count--;
        }

    }  
    return ans

Q: Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.
Example 1:
Input: height = [0,1,0,2,1,0,1,3,2,1,2,1]
Output: 6
Explanation: The above elevation map (black section) is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped.
Example 2:
Input: height = [4,2,0,3,2,5]
Output: 9

Sol:var trap = function(height) {
     let left = new Array(height.length);
    let right= new Array(height.length);
    let sum = 0;
    let maxLeft = height[0];
    let maxRight = height[height.length-1]
    left[0] = maxLeft;
    right[right.length -1] = maxRight;
    for(let i=1;i<height.length;i++){
        maxLeft = Math.max(maxLeft, height[i]);
        left[i] = maxLeft;
    }
    for(let j= height.length-2;j>=0;j--){
        maxRight= Math.max(maxRight, height[j]);
        right[j] = maxRight;
    }

    for(let i=0;i<height.length;i++){
        sum += Math.min(right[i], left[i]) - height[i]
    }
    return sum;
};

Q: Count characters.
const message = 'Hello world'; // Try edit me
let charCount = {};

for (let i = 0; i < message.length; i++) {
  console.log(message[i]);
 
  if (charCount[message[i]]) {
    charCount[message[i]] = charCount[message[i]] + 1;
  } else {
    charCount[message[i]] = 1;
    
  }
}

Q: Bubble Sort.
Sol:

let arr = [10,5,1,12,3];

for(let i=0;i<arr.length-1;i++){
    // console.log(i,"i")
    let bubble = arr[0];
    console.log(bubble)
    for(let j=0;j<arr.length;j++){
        // console.log(j,"j")
        if(bubble > arr[j+1]){
            let temp = arr[j];
            arr[j] =arr[j+1]
            arr[j+1] = temp;
        }else{
            bubble = arr[j+1];
        }
    }
    console.log(arr,"arr after loop", i)
}

console.log(arr)


Q: Given a signed 32-bit integer x, return x with its digits reversed. If reversing x causes the value to go outside the signed 32-bit integer range [-231, 231 - 1], then return 0.
Assume the environment does not allow you to store 64-bit integers (signed or unsigned).
Sol:
 var reverse = function(x) {
    let y= Math.abs(x);
    let n = y.toString().length;
    let mod = '';
    const INT_MAX = 2 ** 31 - 1;
    const INT_MIN = -(2 ** 31);
     // Before appending the digit, check overflow:
  

      for(let i= 0;i<n;i++){
        mod+= parseInt(y%10);
        y = y/10;
      }  
      if (parseInt(mod) > INT_MAX || parseInt(mod) < INT_MIN) return 0;
      if(x < 0) mod = -(mod);


  return +(mod)
};
